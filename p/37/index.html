<!DOCTYPE HTML>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="Stylesheet" type="text/css" href="/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/css/tango.css">
        <link rel="Stylesheet" type="text/css" href="/css/github-markdown.css">
        <title>涵曦 ~ 博客</title>
        <script src="/config.js"></script>
        <script src="/util.js"></script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-139883805-2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-139883805-2');
        </script>
    </head>

    <body>
        <div id="header">
            <div id="post-nav">
                <a href="/">首页</a>
                <a href="/about.html">关于</a>
                <a href="/sitemap.html">所有文章</a>
            </div>
        </div>
        <div id="container">
            <div id="title">我是如何制作一个远程剪切板的【流水账】</div>
            <div id="content" class="markdown-body">
                <p>服务器选用了 openresty。 选用服务器考虑了性能和生态，网络协议需要 HTTP 和 Websocket。也想过用 skynet， 虽然 skynet 也已实现了 websocket，但还是选择了在 web 领域应用更广泛的框架。</p>
<p>初版的客户端只是一个 bash 脚本，调用 openssl 本地加密解密数据，并用 curl 推送或者拉取数据到服务器。正式的客户端还是选用了 Lua 语言做主要的开发语言，C 语言作为 Lua 的扩展库开发语言。</p>
<p>服务器最初是先实现了 copy 和 paste 两个协议，copy 采用 POST (把本地数据推送到服务器), paste 采用 GET (从服务器拉取数据)。数据采用文件的形式存盘在服务器。</p>
<p>然后做一个账号系统来验证登录，本来打算自己实现一套账号系统的，但是担心用户注册麻烦，最终还是选用了 GitHub OAuth 的方式来登录。这个实现主要是接入 GitHub 的 API，拿到 token 和用户信息之后保存到服务器，再给用户生成一个 JWT . 之后就客户端使用 JWT 跟服务器交互。</p>
<p>关于使用 GitHub 登录和 JWT 是啥玩意参考这里列出的文章:  <a href="https://blog.hanxi.info/?p=34" rel="nofollow">https://blog.hanxi.info/?p=34</a></p>
<p>网站的主页页面也就两个，一个主页，一个登录后的个人页面。后端采用的模板库是 bungle/lua-resty-template , 前端采用了 Bootstrap 库。登录成功后就能显示 JWT ，还弄了个自动安装客户端的命令。然后实现点击按钮复制命令的实现可看这里: <a href="https://blog.hanxi.info/?p=35" rel="nofollow">https://blog.hanxi.info/?p=35</a></p>
<p>初版的 Linux 客户端的配置文件在 <code>$HOME/.oclip</code> ，安装位置在 <code>$HOME/.local/bin</code> 。实现过程中用到的一些 Bash 脚本关键点记录在这里: <a href="https://blog.hanxi.info/?p=33" rel="nofollow">https://blog.hanxi.info/?p=33</a></p>
<p>到这里就已经实现了一个初步可用的远程剪切板了，使用流程为 进入到 <a href="https://oclip.hanxi.info" rel="nofollow">https://oclip.hanxi.info</a> ，然后用 GitHub 登录，再复制安装命令到系统终端执行(不用 root 账户)，然后就能使用 oclip 命令了。 oclip 的参数格式参考了 xclip。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 复制</span>
<span class="pl-c1">echo</span> hello <span class="pl-k">|</span> oclip

<span class="pl-c"><span class="pl-c">#</span> 粘贴</span>
oclip -o</pre></div>
<p>然后在本地测试速度还可以 0.0xx 秒:</p>
<pre><code>real    0m0.046s
user    0m0.015s
sys     0m0.002s
</code></pre>
<p>远程测试速度为，可能慢在 HTTPS 连接上。</p>
<pre><code>real    0m0.392s
user    0m0.129s
sys     0m0.097s
</code></pre>
<p>最初想用 websocket 不是为了解决速度的问题，而是需要一个长连接的机制来实现监控和修改 Windows 的系统粘贴板。比如我在 Linux 上执行复制命令 <code>echo hello|oclip</code> ，然后数据可以自动推送到 Windows 上并修改系统粘贴板。</p>
<p>确定好 Windows 客户端使用 Lua 开发后，需要使用的库大致分为操作系统剪切板，系统图标，websocket。</p>
<p>系统剪切板的操作有现成的 Lua 库 <a href="http://files.luaforge.net/releases/jaslatrix/clipboard" rel="nofollow">jaslatrix/clipboard</a>，但是好多功能是我不需要的，而且没有监听剪切板的功能，因此我就参考它和 <a href="https://docs.microsoft.com/en-us/windows/win32/dataxchg/using-the-clipboard" rel="nofollow">MSDN</a> 自己实现了一个 <a href="https://github.com/hanxi/lclipboard">hanxi/lclipboard</a></p>
<p>系统图标也找到了一个 C 库 <a href="https://github.com/zserge/tray">zserge/tray</a> ，对它进行修改调整实现了一个 Lua 库 <a href="https://github.com/hanxi/ltray">hanxi/ltray</a></p>
<p>剩下最后一个大问题了，websocket 库如何选择？服务端用 openresty 的官方自带了 websocket 库，客户端找了好多，最后还是觉得下面两个比较合适:</p>
<ul>
<li><a href="https://github.com/daurnimator/lua-http">daurnimator/lua-http</a></li>
<li><a href="https://github.com/lipp/lua-websockets">lipp/lua-websockets</a></li>
</ul>
<p>但是 <code>lua-http</code> 依赖的 <code>cqueues</code> 不支持 Windows，自己去适配的话太耗时间了，最终选了 <code>lua-websockets</code> 这个库，然后参考 <a href="https://github.com/RamiLego4Game/Love-Discord">RamiLego4Game/Love-Discord</a> 改成异步的接口，放在这里了 <a href="https://github.com/hanxi/lua-websockets">hanxi/lua-websockets</a></p>
<p>为了支持 https 和 wss。 编译 luasec 花了点时间，网上找的 openssl 二进制包都有点问题，最后自己安装 perl 编译了一个 openssl 就没问题了。</p>
<p>还差一个交互协议的选择，最后的决定是参考 JSON-RPC，用 msgpack 格式打包类似的结构进行交互。msgpack 库打算用 Redis 的 <a href="https://github.com/antirez/lua-cmsgpack">antirez/lua-cmsgpack</a>，最后发现 Openresty 安装时由于没装编译环境导致安装失败。所以选用了纯 Lua 实现的 <a href="https://framagit.org/fperrad/lua-MessagePack" rel="nofollow">fperrad/lua-MessagePack</a>。</p>
<p>Windows 客户端的零件都准备好了，可以开始组装了。</p>
<hr>
<p>出现一个本地加密数据的问题， luasec 没有提供 openssl enc 接口，然后找到 luacrypto 和 lua-openssl。最后发现 lua-openssl 兼容了 luacrypto 和 luasec。 这样就可以只用 lua-openssl 替代 luacrypto 和 luasec 了。</p>
<p>在 windows 下编译 lua-openssl 比较顺畅， 它提供了 makefile.win, 在编译 luasec 的基础上参考它就编译成功了。 最后使用 lua-openssl 的时候，遇到了两个问题：</p>
<ul>
<li><code>send</code> 和 <code>receive</code> 接口的实现跟 luasocket 实现的不一致，不能调用 <code>select</code> 函数。</li>
<li><code>crypto.digest</code> 函数漏了 <code>raw</code> 参数没有往下面传递。</li>
</ul>
<p>然后我都提了 issues 并修复了。</p>
<p><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="484080367" data-permission-text="Title is private" data-url="https://github.com/zhaozg/lua-openssl/issues/179" data-hovercard-type="issue" data-hovercard-url="/zhaozg/lua-openssl/issues/179/hovercard" href="https://github.com/zhaozg/lua-openssl/issues/179">zhaozg/lua-openssl#179</a></p>
<p><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="484291462" data-permission-text="Title is private" data-url="https://github.com/zhaozg/lua-openssl/issues/180" data-hovercard-type="issue" data-hovercard-url="/zhaozg/lua-openssl/issues/180/hovercard" href="https://github.com/zhaozg/lua-openssl/issues/180">zhaozg/lua-openssl#180</a></p>
<p>接下来就是遇到 <code>openssl enc</code> 加密的数据， lua-openssl 解密不了的问题。这里需要去理解 <code>-K -iv</code> 参数的生成规则才行。</p>
<p>参考这里： <a href="https://www.jianshu.com/p/813e184b56bd" rel="nofollow">https://www.jianshu.com/p/813e184b56bd</a></p>
<p>AES-128-CBC 的 Key 和 iv 生成规则</p>
<pre><code>hash1_256 = SHA256(Passphrase)
Key = First128bit(hash1_256)
IV = Second128bit(hash1_256)
</code></pre>
<p>等处理完数据加密解密，这个 Windows 客户端基本就基本完工了。</p>
<p>更新: 本地数据加密解密函数封装如下</p>
<div class="highlight highlight-source-lua"><pre><span class="pl-k">local</span> <span class="pl-k">function</span> <span class="pl-en">get_key_iv</span>(<span class="pl-smi">passwd</span>)
  hash_256 <span class="pl-k">=</span> digest.<span class="pl-c1">digest</span>(<span class="pl-s"><span class="pl-pds">'</span>sha256<span class="pl-pds">'</span></span>, passwd)
  <span class="pl-k">local</span> key <span class="pl-k">=</span> hash_256:<span class="pl-c1">sub</span>(<span class="pl-c1">1</span>, <span class="pl-c1">32</span>)
  <span class="pl-k">local</span> iv <span class="pl-k">=</span> hash_256:<span class="pl-c1">sub</span>(<span class="pl-c1">33</span>, <span class="pl-c1">64</span>)
  key <span class="pl-k">=</span> openssl.<span class="pl-c1">hex</span>(key, <span class="pl-c1">false</span>)
  iv <span class="pl-k">=</span> openssl.<span class="pl-c1">hex</span>(iv, <span class="pl-c1">false</span>)
  <span class="pl-k">return</span> key, iv
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_M.decrypt</span>(<span class="pl-smi">data</span>)
  <span class="pl-k">local</span> passwd <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>passwd<span class="pl-pds">'</span></span>
  <span class="pl-k">local</span> key, iv <span class="pl-k">=</span> <span class="pl-c1">get_key_iv</span>(passwd)
  <span class="pl-k">return</span> cipher.<span class="pl-c1">decrypt</span>(<span class="pl-s"><span class="pl-pds">'</span>aes-128-cbc<span class="pl-pds">'</span></span>, data, key, iv)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_M.encrypt</span>(<span class="pl-smi">data</span>)
  <span class="pl-k">local</span> passwd <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>passwd<span class="pl-pds">'</span></span>
  <span class="pl-k">local</span> key, iv <span class="pl-k">=</span> <span class="pl-c1">get_key_iv</span>(passwd)
  <span class="pl-k">return</span> cipher.<span class="pl-c1">encrypt</span>(<span class="pl-s"><span class="pl-pds">'</span>aes-128-cbc<span class="pl-pds">'</span></span>, data, key, iv)
<span class="pl-k">end</span></pre></div>
<p>对应 openssl 命令为:</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-k">if</span> [ <span class="pl-smi">$oclip_type</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>copy<span class="pl-pds">"</span></span> ]<span class="pl-k">;</span> <span class="pl-k">then</span>
    cat -- <span class="pl-smi">$input_file</span> <span class="pl-k">|</span> openssl enc -e -aes-128-cbc -nosalt -pass pass:<span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$passwd</span><span class="pl-pds">"</span></span> <span class="pl-k">|</span> curl  -H <span class="pl-s"><span class="pl-pds">"</span>Authorization: token <span class="pl-smi">$token</span><span class="pl-pds">"</span></span> -X POST --data-binary @- https://oclip.hanxi.info/clip
<span class="pl-k">else</span>
    curl -s -H <span class="pl-s"><span class="pl-pds">"</span>Authorization: token <span class="pl-smi">$token</span><span class="pl-pds">"</span></span> https://oclip.hanxi.info/clip <span class="pl-k">|</span> openssl enc -d -aes-128-cbc -nosalt -pass pass:<span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$passwd</span><span class="pl-pds">"</span></span>
<span class="pl-k">fi</span></pre></div>
<p>更新：<br>
遇到 openssl 版本不一致的情况，导致生成的 key 和 iv 的结果不一致，于是改成手动采用 sha256 计算 key 和 iv。加密解密指令如下：</p>
<div class="highlight highlight-source-shell"><pre>sha256code=<span class="pl-s"><span class="pl-pds">$(</span>echo -n <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$passwd</span><span class="pl-pds">"</span></span> <span class="pl-k">|</span> openssl sha256 -hex -r <span class="pl-k">|</span> cut -b -64<span class="pl-pds">)</span></span>
key=<span class="pl-s"><span class="pl-pds">$(</span>echo -n <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$sha256code</span><span class="pl-pds">"</span></span> <span class="pl-k">|</span> cut -b -32<span class="pl-pds">)</span></span>
iv=<span class="pl-s"><span class="pl-pds">$(</span>echo -n <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$sha256code</span><span class="pl-pds">"</span></span> <span class="pl-k">|</span> cut -b 33-<span class="pl-pds">)</span></span>
<span class="pl-k">if</span> [ <span class="pl-smi">$oclip_type</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>copy<span class="pl-pds">"</span></span> ]<span class="pl-k">;</span> <span class="pl-k">then</span>
    cat -- <span class="pl-smi">$input_file</span> <span class="pl-k">|</span> openssl enc -e -aes-128-cbc -nosalt -K <span class="pl-smi">$key</span> -iv <span class="pl-smi">$iv</span> <span class="pl-k">|</span> curl  -H <span class="pl-s"><span class="pl-pds">"</span>Authorization: token <span class="pl-smi">$token</span><span class="pl-pds">"</span></span> -X POST --data-binary @- https://oclip.hanxi.info/clip
<span class="pl-k">else</span>
    curl -s -H <span class="pl-s"><span class="pl-pds">"</span>Authorization: token <span class="pl-smi">$token</span><span class="pl-pds">"</span></span> https://oclip.hanxi.info/clip <span class="pl-k">|</span> openssl enc -d -aes-128-cbc -nosalt -K <span class="pl-smi">$key</span> -iv <span class="pl-smi">$iv</span>
<span class="pl-k">fi</span></pre></div>
<hr>
<p>再补充下服务器是如何同步最新的数据到客户端的。</p>
<p>每个账号最新记录的版本号，采用 openresty 的 shared.DICT 存在内存中。每次有数据变化后，把版本加一。<br>
用心跳去检查各个客户端的数据版本号是否已过期，过期则更新版本号再推送数据。</p>
<div class="highlight highlight-source-lua"><pre> <span class="pl-c"><span class="pl-c">--</span> update data version id</span>
<span class="pl-k">local</span> clip_change <span class="pl-k">=</span> ngx.<span class="pl-smi">shared</span>.<span class="pl-smi">clip_change</span>
<span class="pl-k">local</span> vid <span class="pl-k">=</span> clip_change:<span class="pl-c1">incr</span>(<span class="pl-c1">self</span>.<span class="pl-smi">uid</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>)
<span class="pl-c1">self</span>.<span class="pl-smi">vid</span> <span class="pl-k">=</span> vi</pre></div>
<p>使用 shared.DICT 而不是使用 lua-resty-lru 的原因是：这个数据需要在各个工作进程中共享, 因为不同的客户端连接的可能不是同一个进程。</p>
<hr>
<p>遇到 <code>ssl.bio</code> 发送很长数据的问题，<code>send</code> 时返回需要重试，还没想到比较好的解决办法，直接写了个死循环一直发送。这个得再想办法改下。</p>
<p>还要处理 Lua 读取配置文件的问题, 预计采用类似 ini 文件格式, 跟 Linux 系统一致, 放到用户目录下, 并命名为 <code>.oclip</code></p>
<pre><code>token=eyJhbG.eyJ.rWe...
passwd=passwd
</code></pre>
<p>读取每行配置，用 gmatch 提取 key 和 value</p>
<div class="highlight highlight-source-lua"><pre><span class="pl-k">local</span> line <span class="pl-k">=</span> f:<span class="pl-c1">read</span>(<span class="pl-s"><span class="pl-pds">"</span>l<span class="pl-pds">"</span></span>) 
<span class="pl-k">while</span> line <span class="pl-k">do</span>
  <span class="pl-k">local</span> k,v <span class="pl-k">=</span> line:<span class="pl-c1">gmatch</span>(<span class="pl-s"><span class="pl-pds">"</span>(%w+)[^=]*=%s*(.*)<span class="pl-pds">"</span></span>)()
  <span class="pl-k">if</span> k <span class="pl-k">and</span> v <span class="pl-k">then</span>
    config[k] <span class="pl-k">=</span> v
    <span class="pl-c1">print</span>(k, <span class="pl-s"><span class="pl-pds">"</span>=<span class="pl-pds">"</span></span>, v)
  <span class="pl-k">end</span> 
  line <span class="pl-k">=</span> f:<span class="pl-c1">read</span>(<span class="pl-s"><span class="pl-pds">"</span>l<span class="pl-pds">"</span></span>) 
<span class="pl-k">end</span></pre></div>
<p>Windows 客户端逻辑写完之后就是剩下打包的工作了，打算用 lua-static 来打包。 打包前还要处理下系统图标的打包工作。</p>
<p>luastatic 在 windows 下打包默认只支持 mingw, 可是我编译用的是 MSVC，主要遇到三个问题:</p>
<ul>
<li>nm.exe 读取 windows 里的 DLL 文件无效，改成 <code>set NM="dumpbin /EXPORTS"</code> 后解决</li>
<li><code>is_binary_library</code> 需要加入后缀 <code>dll</code> 的判断</li>
<li>使用 cl.exe 生成的 dll 或者 lib 无法链接到生成的 exe 文件，可能是某些参数问题。最后试了一个复杂的方法，把所有相关的 obj 文件放在一起 link，最后生成了可以运行的单个 exe 文件。</li>
</ul>
<p>最后又遇到了一个小问题 cacert.pem文件没有打包到 exe 文件，这个比较简单，写个 lua 函数把这个文件从字符串输出到临时文件就行。</p>
<div class="highlight highlight-source-lua"><pre><span class="pl-k">local</span> cacert_content <span class="pl-k">=</span> <span class="pl-c1">require</span> <span class="pl-s"><span class="pl-pds">'</span>oclip.cacert<span class="pl-pds">'</span></span>
<span class="pl-k">local</span> fname <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>cacert.pem<span class="pl-pds">'</span></span>

<span class="pl-c"><span class="pl-c">--</span> 判断文件是否存在</span>
<span class="pl-k">function</span> <span class="pl-en">_M.file_exists</span>(<span class="pl-smi">name</span>)
  <span class="pl-k">local</span> f <span class="pl-k">=</span> <span class="pl-c1">io.open</span>(name, <span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>)
  <span class="pl-k">if</span> f <span class="pl-k">~=</span> <span class="pl-c1">nil</span> <span class="pl-k">then</span>
    <span class="pl-c1">io.close</span>(f)
    <span class="pl-k">return</span> <span class="pl-c1">true</span>
  <span class="pl-k">else</span>
    <span class="pl-k">return</span> <span class="pl-c1">false</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_M.get</span>()
    <span class="pl-k">if</span> _M.<span class="pl-c1">file_exists</span>(fname) <span class="pl-k">then</span>
      <span class="pl-k">return</span> fname
    <span class="pl-k">end</span>
    fname <span class="pl-k">=</span> <span class="pl-c1">os.tmpname</span>()
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>tmpfile: <span class="pl-pds">'</span></span>, fname)
    <span class="pl-k">local</span> f <span class="pl-k">=</span> <span class="pl-c1">io.open</span>(fname, <span class="pl-s"><span class="pl-pds">'</span>w+<span class="pl-pds">'</span></span>)
    <span class="pl-k">if</span> f <span class="pl-k">then</span>
        f:<span class="pl-c1">write</span>(cacert_content)
        f:<span class="pl-c1">close</span>()
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> fname
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_M.exit</span>()
    <span class="pl-k">if</span> fname <span class="pl-k">~=</span> <span class="pl-s"><span class="pl-pds">'</span>cacert.pem<span class="pl-pds">'</span></span> <span class="pl-k">then</span>
        <span class="pl-c1">os.remove</span>(fname)
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p>生成 src/cacert.lua 的脚本如下：</p>
<div class="highlight highlight-source-batchfile"><pre><span class="pl-c"><span class="pl-c">: </span>gen src/cacert.lua</span>
<span class="pl-k">cd</span> /d <span class="pl-smi">%cur_dir%</span>\..\..\src
<span class="pl-k">echo</span> return [[ <span class="pl-k">&gt;</span> cacert.lua
<span class="pl-k">type</span> cacert.pem <span class="pl-k">&gt;&gt;</span> cacert.lua
<span class="pl-k">echo</span> ]] <span class="pl-k">&gt;&gt;</span> cacert.lua</pre></div>
<hr>
<p>更新：</p>
<p>文本的编码问题，统一转成 utf8</p>
<p>编码问题进展: 采用下面两个函数对剪切板的内容转换，可以正常处理中文了，但是 emoji 处理不了。还得继续找找原因。</p>
<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> *<span class="pl-en">asciitoutf8</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *lpstr)
{
    <span class="pl-k">int</span> ulen = <span class="pl-c1">MultiByteToWideChar</span>(CP_ACP, <span class="pl-c1">0</span>, lpstr, -<span class="pl-c1">1</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>);
    <span class="pl-k">int</span> bytes = (ulen + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-c1">wchar_t</span>);
    <span class="pl-c1">wchar_t</span> *utext = <span class="pl-c1">malloc</span>(bytes);
    <span class="pl-c1">MultiByteToWideChar</span>(CP_ACP, <span class="pl-c1">0</span>, lpstr, -<span class="pl-c1">1</span>, utext, ulen);

    <span class="pl-k">int</span> sz = <span class="pl-c1">WideCharToMultiByte</span>(CP_UTF8, <span class="pl-c1">0</span>, utext, -<span class="pl-c1">1</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-k">char</span> *utf8text = <span class="pl-c1">malloc</span>(sz);
    <span class="pl-c1">WideCharToMultiByte</span>(CP_UTF8, <span class="pl-c1">0</span>, utext, -<span class="pl-c1">1</span>, utf8text, sz, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-c1">free</span>(utext);
    <span class="pl-k">return</span> utf8text;
}
<span class="pl-k">char</span> *<span class="pl-en">utf8toascii</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *text, <span class="pl-k">int</span> *sz)
{
    <span class="pl-k">int</span> ulen = <span class="pl-c1">MultiByteToWideChar</span>(CP_UTF8, <span class="pl-c1">0</span>, text, -<span class="pl-c1">1</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>);
    <span class="pl-k">int</span> bytes = (ulen + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-c1">wchar_t</span>);
    <span class="pl-c1">wchar_t</span> *utext = <span class="pl-c1">malloc</span>(bytes);
    <span class="pl-c1">MultiByteToWideChar</span>(CP_UTF8, <span class="pl-c1">0</span>, text, -<span class="pl-c1">1</span>, utext, ulen);

    *sz = <span class="pl-c1">WideCharToMultiByte</span>(CP_ACP, <span class="pl-c1">0</span>, utext, -<span class="pl-c1">1</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-k">char</span> *asciitext = <span class="pl-c1">malloc</span>(*sz);
    <span class="pl-c1">WideCharToMultiByte</span>(CP_ACP, <span class="pl-c1">0</span>, utext, -<span class="pl-c1">1</span>, asciitext, *sz, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-c1">free</span>(utext);
    <span class="pl-k">return</span> asciitext;
}</pre></div>
<hr>
<p>更新：</p>
<p>编码问题终于解决了,我傻逼了,主要原因是剪切板内容读取和设置的格式采用了 ASCII 格式 <code>CF_TEXT</code>. 所以还是相当于没有使用 <code>define UNICODE</code>. 今天试过 iconv 来转都是一样的效果,最后找到这个才发现需要改为 <code>CF_UNICODETEXT</code>.</p>
<p><a href="https://github.com/ocornut/imgui/blob/f5243712ce9fb070370cdc847ccc1b8e655fb1ce/imgui.cpp#L9616-L9658">https://github.com/ocornut/imgui/blob/f5243712ce9fb070370cdc847ccc1b8e655fb1ce/imgui.cpp#L9616-L9658</a></p>
<p>所以 utf8 和 utf16 互转的代码其实只要这样就行了</p>
<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> * <span class="pl-en">malloc_utf16_to_utf8</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *utf16text)
{
    <span class="pl-k">int</span> sz = <span class="pl-c1">WideCharToMultiByte</span>(CP_UTF8, <span class="pl-c1">0</span>, utf16text, -<span class="pl-c1">1</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-k">char</span> *utf8text = <span class="pl-c1">malloc</span>(sz);
    <span class="pl-c1">WideCharToMultiByte</span>(CP_UTF8, <span class="pl-c1">0</span>, utf16text, -<span class="pl-c1">1</span>, utf8text, sz, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-k">return</span> utf8text;
}

<span class="pl-c1">wchar_t</span> * <span class="pl-en">malloc_utf8_to_utf16</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *utf8text)
{
    <span class="pl-k">int</span> utf16len = <span class="pl-c1">MultiByteToWideChar</span>(CP_UTF8, <span class="pl-c1">0</span>, utf8text, -<span class="pl-c1">1</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>);
    <span class="pl-k">int</span> bytes = (utf16len + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-c1">wchar_t</span>);
    <span class="pl-c1">wchar_t</span> *utf16text = <span class="pl-c1">malloc</span>(bytes);
    <span class="pl-c1">MultiByteToWideChar</span>(CP_UTF8, <span class="pl-c1">0</span>, utf8text, -<span class="pl-c1">1</span>, utf16text, utf16len);
    <span class="pl-k">return</span> utf16text;
}</pre></div>
<p>当然调用上面的函数后记得 free.</p>
<p>iconv 测试代码找的这个:  <a href="https://gist.github.com/duedal/1221865">https://gist.github.com/duedal/1221865</a><br>
iconv windows 版本找的这个: <a href="https://github.com/kiyolee/libiconv-win-build">https://github.com/kiyolee/libiconv-win-build</a></p>
<p>编码问题已经搞定. 客户端代码在这里 <a href="https://github.com/hanxi/oclip-client">hanxi/oclip-client</a></p>
<br>
<p>打包成 exe 文件：</p>
<p>Windows 客户端打独立 exe 包的工作算完成一个段落了，用的 lua-static 来打包。还需要处理下系统图标的打包工作。</p>
<p>系统图标在 C 代码里实现了把系统图标导出到 icon.h 文件再编译，但是我想在 Lua 里在实现一次，这样修改图标不用再次编译 tray.dll。实现的方法是从 <a href="https://github.com/getlantern/systray">getlantern/systray</a> 里面借鉴来的，先把 icon 文件打包成 16 进制的 bytes 放到源码里，然后在启动的时候加载就行，不过我的实现有点不一样，我把 bytes 存在了临时文件，然后在加载，直接加载直接没成功，得抽个时间把这个改成直接加载 bytes 更合适。</p>
<p>更正：</p>
<p>getlantern/systray 使用的方法也是先把 icon 写入文件，然后再加载的。 <a href="https://github.com/getlantern/systray/blob/master/systray_windows.go#L658-L674">https://github.com/getlantern/systray/blob/master/systray_windows.go#L658-L674</a>  并且写入的文件名是根据 bytes 计算 MD5 拼接的。</p>
<p>然后我就把 ltray 的文件名也改成不是固定的文件名了，用临时的文件名。程序结束时删除就行。</p>
<div class="highlight highlight-source-c"><pre><span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">_set_default_icon</span>(<span class="pl-c1">wchar_t</span> *icon_path)
{
    <span class="pl-c1">memset</span>(icon_path, <span class="pl-c1">0</span>, MAX_PATH);
    <span class="pl-c1">_wtmpnam</span>(icon_path);
    default_icon_path = icon_path;
    FILE *fp = <span class="pl-c1">_wfopen</span>(icon_path, L<span class="pl-s"><span class="pl-pds">"</span>wb<span class="pl-pds">"</span></span>);
    <span class="pl-k">if</span> (fp)
    {
        <span class="pl-c1">fwrite</span>(icon_bytes, <span class="pl-k">sizeof</span>((icon_bytes)[<span class="pl-c1">0</span>]), <span class="pl-k">sizeof</span>(icon_bytes), fp);
        <span class="pl-c1">fclose</span>(fp);
    }
}

<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">_remove_default_icon_file</span>()
{
    <span class="pl-k">if</span> (default_icon_path != <span class="pl-c1">NULL</span>)
    {
        <span class="pl-c1">_wremove</span>(default_icon_path);
    }
}</pre></div>
<p>更新：</p>
<ul>
<li>
<ol>
<li>在 Lua 实现图标文件从内存中加载，实现过程同 C 里的步骤。 [已经实现]</li>
</ol>
</li>
<li>
<ol start="2">
<li>开机启动 [已经实现]</li>
</ol>
</li>
</ul>
<p>创建快捷方式的方法打算采用 os.execute() 来执行 mklink 命令。 参考这里： <a href="https://stackoverflow.com/questions/30028709/how-do-i-create-a-shortcut-via-command-line-in-windows" rel="nofollow">https://stackoverflow.com/questions/30028709/how-do-i-create-a-shortcut-via-command-line-in-windows</a></p>
<pre><code>mklink "%userprofile%\Start Menu\Programs\Startup\%~nx0" "%~f0"
</code></pre>
<p>创建快捷方式遇到个权限问题，win10 需要管理员权限才能 mklink. 于是网上找了个 VBS 脚本调用 UAC 执行。代码有点绕，但是可以实现功能就行。</p>
<div class="highlight highlight-source-lua"><pre><span class="pl-k">function</span> <span class="pl-en">_M.set_auto_startup</span>()
  <span class="pl-k">local</span> create_dir_cmd <span class="pl-k">=</span> <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">'</span>setlocal EnableExtensions &amp; mkdir %q<span class="pl-pds">'</span></span>, startup_dir)
  <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>create_dir_cmd:<span class="pl-pds">'</span></span>, create_dir_cmd)
  <span class="pl-c1">os.execute</span>(create_dir_cmd)
  <span class="pl-k">local</span> mklink_cmd <span class="pl-k">=</span> <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">'</span>mklink %q %q<span class="pl-pds">'</span></span>, link_file_name, arg[<span class="pl-c1">0</span>])
  <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>mklink_cmd:<span class="pl-pds">'</span></span>, mklink_cmd)

  <span class="pl-k">local</span> fname <span class="pl-k">=</span> <span class="pl-c1">os.tmpname</span>()<span class="pl-k">..</span><span class="pl-s"><span class="pl-pds">"</span>.bat<span class="pl-pds">"</span></span>
  <span class="pl-k">local</span> f <span class="pl-k">=</span> <span class="pl-c1">io.open</span>(fname, <span class="pl-s"><span class="pl-pds">'</span>w+<span class="pl-pds">'</span></span>)

  <span class="pl-c"><span class="pl-c">--</span> Need use uac create link.</span>
  f:<span class="pl-c1">write</span>(<span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">'</span>echo %s &gt; "%%temp%%<span class="pl-cce">\\</span>run.bat"<span class="pl-cce">\n</span><span class="pl-pds">'</span></span>, mklink_cmd))
  f:<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">[[</span></span>
<span class="pl-s">&gt;nul 2&gt;&amp;1 "%SYSTEMROOT%\system32\cacls.exe" "%SYSTEMROOT%\system32\config\system"  </span>
<span class="pl-s">if '%errorlevel%' NEQ '0' (    echo Requesting administrative privileges...    goto UACPrompt) else ( goto gotAdmin )</span>
<span class="pl-s">:UACPrompt</span>
<span class="pl-s">    echo Set UAC = CreateObject^("Shell.Application"^) &gt; "%temp%\getadmin.vbs"</span>
<span class="pl-s">    echo UAC.ShellExecute "%temp%\run.bat", "", "", "runas", 0 &gt;&gt; "%temp%\getadmin.vbs"</span>
<span class="pl-s">    "%temp%\getadmin.vbs"</span>
<span class="pl-s">    exit /B</span>
<span class="pl-s">:gotAdmin</span>
<span class="pl-s">"%temp%\run.bat"</span>
<span class="pl-s"><span class="pl-pds">]]</span></span>)
  f:<span class="pl-c1">write</span>(mklink_cmd)
  f:<span class="pl-c1">close</span>()
  <span class="pl-k">local</span> cmd <span class="pl-k">=</span> <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">"</span>call %q<span class="pl-pds">"</span></span>, fname)
  <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>cmd:<span class="pl-pds">"</span></span>, cmd)
  <span class="pl-c1">os.execute</span>(cmd)
  <span class="pl-c1">os.remove</span>(fname)
<span class="pl-k">end</span></pre></div>
<p>再更新：<br>
既然已经用了 vbs 来创建快捷方式了，那干脆就不用 mklink 命令，所以也就不需要管理员权限了，直接改成下面的就可以了：</p>
<div class="highlight highlight-source-lua"><pre><span class="pl-k">local</span> userprofile <span class="pl-k">=</span> <span class="pl-c1">os.getenv</span>(<span class="pl-s"><span class="pl-pds">'</span>USERPROFILE<span class="pl-pds">'</span></span>)
<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>userprofile:<span class="pl-pds">'</span></span>, userprofile)
<span class="pl-k">local</span> startup_dir <span class="pl-k">=</span>
  <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">'</span>%s<span class="pl-cce">\\</span>AppData<span class="pl-cce">\\</span>Roaming<span class="pl-cce">\\</span>Microsoft<span class="pl-cce">\\</span>Windows<span class="pl-cce">\\</span>Start Menu<span class="pl-cce">\\</span>Programs<span class="pl-cce">\\</span>Startup<span class="pl-pds">'</span></span>, userprofile)
<span class="pl-k">local</span> link_file_name <span class="pl-k">=</span> <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">"</span>%s<span class="pl-cce">\\</span>oclip.lnk<span class="pl-pds">"</span></span>, startup_dir)

<span class="pl-k">function</span> <span class="pl-en">_M.is_auto_startup</span>()
  <span class="pl-k">if</span> _M.<span class="pl-c1">file_exists</span>(link_file_name) <span class="pl-k">then</span>
    <span class="pl-k">return</span> <span class="pl-c1">true</span>
  <span class="pl-k">end</span>
  <span class="pl-k">return</span> <span class="pl-c1">false</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_M.set_auto_startup</span>()
  <span class="pl-k">local</span> vbs_str <span class="pl-k">=</span> <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">[[</span></span>
<span class="pl-s">set WshShell=WScript.CreateObject("WScript.Shell")</span>
<span class="pl-s">set oShellLink=WshShell.CreateShortcut("%s")</span>
<span class="pl-s">oShellLink.TargetPath="%s"</span>
<span class="pl-s">oShellLink.WindowStyle=1</span>
<span class="pl-s">oShellLink.Description="oclip shortcut"</span>
<span class="pl-s">oShellLink.Save</span>
<span class="pl-s"><span class="pl-pds">]]</span></span>, link_file_name, arg[<span class="pl-c1">0</span>])
  <span class="pl-k">local</span> fname <span class="pl-k">=</span> <span class="pl-c1">os.tmpname</span>()<span class="pl-k">..</span><span class="pl-s"><span class="pl-pds">"</span>.vbs<span class="pl-pds">"</span></span>
  <span class="pl-k">local</span> f <span class="pl-k">=</span> <span class="pl-c1">io.open</span>(fname, <span class="pl-s"><span class="pl-pds">"</span>w+<span class="pl-pds">"</span></span>)
  f:<span class="pl-c1">write</span>(vbs_str)
  f:<span class="pl-c1">close</span>()
  <span class="pl-c1">print</span>(vbs_str)
  <span class="pl-k">local</span> cmd <span class="pl-k">=</span> <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">"</span>call %q<span class="pl-pds">"</span></span>, fname)
  <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>cmd:<span class="pl-pds">"</span></span>, cmd)
  <span class="pl-c1">os.execute</span>(cmd)
  <span class="pl-c1">os.remove</span>(fname)
<span class="pl-k">end</span></pre></div>
<p>接着又处理了下 exe 的图标问题，修改 makefile 即可。生成 icon.rc，再用 rc.exe 生成 icon.res。最后 link 的时候加上 icon.res 就行了。</p>
<pre><code>tmp\icon.rc:
    echo IDI_ICON1 ICON DISCARDABLE "icon.ico" &gt; tmp\icon.rc
tmp\icon.ico:
    copy ..\..\src\icon.ico tmp\icon.ico
tmp\icon.res: tmp\icon.rc tmp\icon.ico
    rc.exe /l 0x404 /Fo"tmp\icon.res" tmp\icon.rc
</code></pre>
<p>处理了下打开配置文件的菜单，直接调用 notepad.exe 来编辑。</p>
<div class="highlight highlight-source-lua"><pre><span class="pl-k">function</span> <span class="pl-en">_M.open_config</span>()
  <span class="pl-k">local</span> fpath <span class="pl-k">=</span> cfg.<span class="pl-c1">get_config_file_path</span>()
  <span class="pl-k">local</span> cmd <span class="pl-k">=</span> <span class="pl-c1">string.format</span>(<span class="pl-s"><span class="pl-pds">"</span>call notepad.exe %s<span class="pl-pds">"</span></span>, fpath)
  <span class="pl-c1">os.execute</span>(cmd)
<span class="pl-k">end</span></pre></div>
<p>还加了个重启菜单，应该不用重启，等补上断线重连的逻辑时，走重连就行。</p>
<br>
<p>更新08/23：<br>
今天把经常断线的问题找到了， 粘贴板有新数据的回调函数不能直接把数据发出去，需要缓存起来，让主线程发送。</p>
<div class="highlight highlight-source-lua"><pre><span class="pl-k">local</span> <span class="pl-k">function</span> <span class="pl-en">on_cliboard_change</span>(<span class="pl-smi">text</span>, <span class="pl-smi">from</span>)
  <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>on_cliboard_change<span class="pl-pds">'</span></span>, from, <span class="pl-k">#</span>text)

  <span class="pl-c"><span class="pl-c">--</span> do not send text in here. need in main thread</span>
  <span class="pl-k">if</span> <span class="pl-k">not</span> from <span class="pl-k">and</span> handler <span class="pl-k">then</span>
    _send_text <span class="pl-k">=</span> text
  <span class="pl-k">end</span>
<span class="pl-k">end</span>
<span class="pl-k">local</span> <span class="pl-k">function</span> <span class="pl-en">clipboard_init</span>()
  clipboard.<span class="pl-c1">init</span>(on_cliboard_change)
<span class="pl-k">end</span></pre></div>
<p>断线重连也搞定了，起一个任务循环判断网络状态，断线则走连接逻辑，连接失败则等 5 秒。</p>
<br>
<p>更新 08/31</p>
<ul>
<li>处理 CRLF 行尾字符的问题</li>
</ul>
<pre><code>Windows end of line sequence:  \r\n
Unix end of line sequence:     \n
Mac end of line sequence:      \r
</code></pre>
<p>现在只支持从 '\r\n' 转 '\n' 和从 '\n' 转 '\r\n' . 单纯的 '\r' 不好转。</p>
<div class="highlight highlight-source-lua"><pre>  <span class="pl-k">if</span> crlf <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>lf<span class="pl-pds">'</span></span> <span class="pl-k">then</span>
    text <span class="pl-k">=</span> text:<span class="pl-c1">gsub</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\r</span><span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)
  <span class="pl-k">elseif</span> crlf <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>crlf<span class="pl-pds">'</span></span> <span class="pl-k">then</span>
    text <span class="pl-k">=</span> text:<span class="pl-c1">gsub</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\r</span><span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)
    text <span class="pl-k">=</span> text:<span class="pl-c1">gsub</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\r\n</span><span class="pl-pds">'</span></span>)
  <span class="pl-k">end</span></pre></div>
<ul>
<li>打个 windows 包</li>
</ul>
<p>在这里下载:</p>
<p><a href="https://github.com/hanxi/oclip-client/releases/tag/v0.0.1">https://github.com/hanxi/oclip-client/releases/tag/v0.0.1</a></p>
<p>更新0903:</p>
<ul>
<li>重写 Linux 客户端</li>
</ul>
<p>Linux 上的客户端打算做成一个包但是分为客户端和服务端，服务端常驻后台跟远程服务器保持连接来更新本地剪切版数据，客户端 copy 数据时则先把数据发送到本地服务端, 本地服务端再推送到远程服务器a，远程服务器 paste 数据回来时则写到本地文件，同时写到 xclip或者xsel。本地客户端和服务端的通信打算采用 unix domain 或者信号。 本地客户端需要拿数据时只需要是本地临时文件取即可。经过几次尝试，最后还是采用了 UDP 的通信方式，使用 <a href="https://github.com/hanxi/lua-signal">lua-signal</a> 出现了一直发送信号的问题没能解决，而且使用 UDP 不需要额外引入第三方库。</p>
<p>目前已经实现完 Linux 客户端逻辑，剩下打一个 Linux 包的事情。新的 Linux 端速度真的很快了，因为只有第一次使用的时候才启动 master 会发起HTTPS连接请求，后续操作都是通过 websocket 发送数据。</p>
<p>更新0905:</p>
<p>可以去这里下载最新的版本了:</p>
<p><a href="https://github.com/oclip/oclip-client/releases">https://github.com/oclip/oclip-client/releases</a></p>
<p>今天解决了 Windows 设置快捷方式的时候出现黑窗口的问题。</p>
<p><a href="https://stackoverflow.com/questions/12554237/hiding-command-prompt-called-by-system/57798301#57798301" rel="nofollow">https://stackoverflow.com/questions/12554237/hiding-command-prompt-called-by-system/57798301#57798301</a></p>
<p>用下面的函数替换 system 函数:</p>
<div class="highlight highlight-source-c"><pre>#<span class="pl-k">define</span> <span class="pl-en">MAX_SYSTEM_PROGRAM</span> (<span class="pl-c1">4096</span>)
<span class="pl-k">static</span> <span class="pl-k">int</span> <span class="pl-en">windows_system</span>(<span class="pl-k">const</span> <span class="pl-c1">wchar_t</span> *cmd)
{
    PROCESS_INFORMATION p_info;
    STARTUPINFO s_info;
    DWORD ReturnValue;

    <span class="pl-c1">memset</span>(&amp;s_info, <span class="pl-c1">0</span>, <span class="pl-k">sizeof</span>(s_info));
    <span class="pl-c1">memset</span>(&amp;p_info, <span class="pl-c1">0</span>, <span class="pl-k">sizeof</span>(p_info));
    s_info.<span class="pl-smi">cb</span> = <span class="pl-k">sizeof</span>(s_info);

    <span class="pl-c1">wchar_t</span> utf16cmd[MAX_SYSTEM_PROGRAM] = {<span class="pl-c1">0</span>};
    <span class="pl-c1">MultiByteToWideChar</span>(CP_UTF8, <span class="pl-c1">0</span>, cmd, -<span class="pl-c1">1</span>, utf16cmd, MAX_SYSTEM_PROGRAM);
    <span class="pl-k">if</span> (<span class="pl-c1">CreateProcessW</span>(<span class="pl-c1">NULL</span>, utf16cmd, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, &amp;s_info, &amp;p_info))
    {
        <span class="pl-c1">WaitForSingleObject</span>(p_info.<span class="pl-smi">hProcess</span>, INFINITE);
        <span class="pl-c1">GetExitCodeProcess</span>(p_info.<span class="pl-smi">hProcess</span>, &amp;ReturnValue);
        <span class="pl-c1">CloseHandle</span>(p_info.<span class="pl-smi">hProcess</span>);
        <span class="pl-c1">CloseHandle</span>(p_info.<span class="pl-smi">hThread</span>);
    }
    <span class="pl-k">return</span> ReturnValue;
}

<span class="pl-k">static</span> <span class="pl-k">int</span> <span class="pl-en">os_execute</span>(lua_State *L)
{
    <span class="pl-k">const</span> <span class="pl-k">char</span> *cmd = <span class="pl-c1">luaL_optstring</span>(L, <span class="pl-c1">1</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-k">int</span> stat = <span class="pl-c1">windows_system</span>(cmd);
    <span class="pl-k">if</span> (cmd != <span class="pl-c1">NULL</span>)
    {
        <span class="pl-k">return</span> <span class="pl-c1">luaL_execresult</span>(L, stat);
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-c1">lua_pushboolean</span>(L, stat); <span class="pl-c"><span class="pl-c">/*</span> true if there is a shell <span class="pl-c">*/</span></span>
        <span class="pl-k">return</span> <span class="pl-c1">1</span>;
    }
}

<span class="pl-c"><span class="pl-c">//</span> 替换 os.execute</span>
<span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">patch_os_system</span>(L)
{
    <span class="pl-c1">lua_getglobal</span>(L, <span class="pl-s"><span class="pl-pds">"</span>os<span class="pl-pds">"</span></span>);
    <span class="pl-c1">lua_pushcfunction</span>(L, os_execute);
    <span class="pl-c1">lua_setfield</span>(L, -<span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>execute<span class="pl-pds">"</span></span>);
    <span class="pl-c1">lua_pop</span>(L, <span class="pl-c1">1</span>);
}</pre></div>
<p>更新完毕。</p>
            </div>
            <div id="comment">
                <a href="https://github.com/hanxi/blog/issues/37#new_comment_field"> 点击进入评论 ... </a>
            </div>
        </div>
        <div id="footer"></div>
    </body>
    <script type="text/javascript">
        setFooter();
    </script>
 
</html>
